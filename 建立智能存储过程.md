- 建立智能存储过程

> 场景：获得订单合计，但要对订单合计增加营业税，不过只针对某些顾客

``` sql
-- Name: ordertotal
-- Parameters: onumber = order number
--				taxable = 0 if not taxable, 1 if taxable
--				ototal = order total variable

CREATE PROCEDURE ordertotal(
	IN onumber INT,
    IN taxable BOOLEAN,
    OUT ototal DECIMAL(8,2)
) COMMENT 'Obtain order total, optionally adding tax'
BEGIN
	-- Declare variable for total
	DECLARE total DECIMAL(8,2);
	-- Declare tax percentage
	DECLARE taxrate INT DEFAULT 6;
	
	-- Get the order total
	SELECT SUM(item_price*quantity) FROM orderitems 
	WHERE order_num = onumber INTO total;
	
	--Is this taxable?
	IF taxable THEN
		-- Yes, so add taxrate to the total
		SELECT total+(total/100*taxrate) INTO total;
	END IF;
	
	-- And finally, save to out variable
	SELECT total INTO ototal;
END //
```

##### 游标(cursor)

> 游标是一个存储在 MySQL 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集，MySQL 游标只能用于存储过程和函数

使用游标

- 创建游标

```sql
CREATE PROCEDUCE processorders()
BEGIN
	-- Declare a cursor named ordernumbers
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
END //
```

- 打开和关闭游标

```sql
CREATE PROCEDUCE processorders()
BEGIN
	-- Declare a cursor named ordernumbers
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
	
	-- Open the cursor
	OPEN ordernumbers;
	
	-- Close the cursor
	-- 不再需要游标时应该关闭，MySQL会在到达END语句时自动关闭游标
	CLOSE ordernumbers;
END //
```

- 使用游标数据

```sql
CREATE PROCEDUCE processorders()
BEGIN
	-- Declare local variables
	DECLARE o INT;
	
	-- Declare the cursor
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
	
	-- Open the cursor
	OPEN ordernumbers;
	
	-- Get order number
	FETCH ordernumbers INTO o;
	
	-- Close the cursor
	CLOSE ordernumbers;
END //
```

```sql
CREATE PROCEDUCE processorders()
BEGIN
	-- Declare local variables
	DECLARE done BOOLEAN DEFAULT 0;
	DECLARE o INT;
	DECLARE t DECIMAL(8,2);
	
	-- Declare the cursor
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
	
	-- Declare continue handler
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;
	
	-- Create a table to store the results
	CREATE TABLE IF NOT EXISTS ordertotals(
        order_num INT, total DECIMAL(8,2));
	
	-- Open the cursor
	OPEN ordernumbers;
	
	-- Loop through all rows
	REPEAT
	
		-- Get order number
		FETCH ordernumbers INTO o;
		--Get the total for this order
		CALL ordertotal(o, 1, t);
		
		-- Insert order and total into ordertotals
		INSERT INTO ordertotals(order_num, total) VALUES(o, t)
		
	-- End of loop
	UNTIL done END REPEAT;
	
	-- Close the cursor
	CLOSE ordernumbers;
END //
```

##### 触发器

> 触发器是在事件发生时(表发生更改)自动执行的语句，事件可为 DELETE、UPDATE、INSERT语句 或位于 BEGIN AND 语句之间的一组语句

创建触发器

```sql
CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added';
```

> 只有表才支持触发器，视图、临时表不支持
>
> 每个表每个事件每次只允许一个触发器，单个触发器不能与多个事件或多个表关联
>
> BEFORE 触发器失败，将不执行请求的操作；BEFORE 触发器失败或语句本身失败，将不执行 AFTER 触发器

删除触发器

```sql
DROP TRIGGER newsproduct;
```

> 触发器不能更新或覆盖，只能删除重建

使用触发器

- INSERT 触发器

  > 在 INSERT 触发器代码内，可引用一个名为 NEW 的虚拟表访问被插入的行
  >
  > 在 BEFORE INSERT 触发器中，NEW 的值也可以被更新，因此通常将 BEFORE 用于数据验证和净化

  ```sql
  CREATE TRIGGER neworder AFTER INSERT ON orders FOR EACH ROW SELECT NEW.order_num;
  ```

- DELETE 触发器

  > 在 DELETE 触发器代码内，可引用一个名为 OLD 的虚拟表访问被删除的行

  ```sql
  -- 在任意订单删除前将被删除的订单存入存档表
  CREATE TRIGGER deteleorder BEFORE DELETE ON orders FOR EACH ROW
  -- 可通过BEGIN AND编写多语句触发器
  BEGIN
  	INSERT INTO archive_orders(order_num, order_date, cust_id) 
  	VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);
  END //
  ```

- UPDATE 触发器

  > 在 UPDATE 触发器代码中，可引用 OLD 虚拟表访问以前的值，引用 NEW 虚拟表访问更新的值

  ```sql
  -- 更新数据时保证州名缩写总是大写
  CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state);
  ```

  

##### 管理事务处理

> 事务(transaction)：一组 SQL 语句
>
> 回退(rollback)：撤销指定 SQL 语句的过程
>
> 提交(commit)：将未存储的 SQL 语句结果写入数据库表
>
> 保留点(savepoint)：事务中临时设置的占位符，可以对它发布回退

开启事务

```sql
START TRANSACTION;
```

回滚事务

> 事务处理用来管理 INSERT、UPDATE、DELETE 语句
>
> 不能回退 SELECT 语句，不能回退 CREATE、DROP 语句

```sql
ROLLBACK;
```

提交事务

> 当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，将来的更改会隐含提交(implicit commit)

```sql
COMMIT;
```

使用保留点

```sql
-- 创建占位符（保留点）
SAVEPOINT delete1;
-- 回退到保留点
ROLLBACK TO delete1;
-- 明确释放保留点（保留点在事务处理完成即执行ROLLBACK或COMMIT语句后自动释放）
RELEASE delete1;
```

更改默认提交行为

```sql
-- 指示 MySQL 不自动提交更改
SET autocommit=0;
```

